$k\in\brace{1,\dotsc,n+1}$.  Start with $k=2$. \\
Return to situation:
\begin{enumerate}
\item[1)] $\abs{\mu_{ij}}\leq\frac12$ for $1\leq j<i<k$
\end{enumerate}
and
\begin{enumerate}
\item[2)] $\abs{\tilde\b_i+\mu_{i,i-1}\tilde\b_{i-1}}^2\geq\frac34\abs{\tilde\b_{i-1}}^2$ for $1<i<k$.
\end{enumerate}
Plainly 1) and 2) hold when $k=2$.

If $k=n+1$ then the basis is reduced and the algorithm terminates.  If $1<k\leq n$ then we first achieve
\begin{equation} \abs{\mu_{k,k-1}}\leq\tfrac12 . \label{three091015} \end{equation}
If~\eqref{three091015} does not hold then let $r$ be the closest integer to $\mu_{k,k-1}$ and replace $\b_k$ by $\b_k-r\b_{k-1}$ in our basis.

This has the effect of replacing $\mu_{k,k-1}$ by $\mu_{k,k-1}-r$ and $\abs{\mu_{k,k-1}-r}\leq\frac12$.  The numbers $\mu_{kj}$ with $j<k-1$ are replaced by $\mu_{kj}-r\mu_{k-1,j}$.  The other $\mu_{ij}$s and $\b_i$s with $i$ different from $k$ and $k-1$ with $i\leq k$ are not changed.  We may now assume that~\eqref{three091015} holds.

We now distinguish two cases: \\
\textbf{Case 1:} If $k\geq2$ and
\[ \abs{\tilde\b_k+\mu_{k,k-1}\tilde\b_{k-1}}^2 < \tfrac34\abs{\tilde\b_{k-1}}^2 \]
then we interchange $\b_k$ and $\b_{k-1}$ in our basis (so $i\neq k\c k-1$).  We leave the other $\b_i$s unchanged.  Notice that $\tilde\b_k$, $\tilde\b_{k-1}$ and the numbers $\mu_{k,k-1}$, $\mu_{k-1,j}$, $\mu_{kj}$, $\mu_{ik}$, $\mu_{i,k-1}$ for $j<k-1$ and $i>k$ are changed.  let us call our new basis $\bc_1\c \dotsc\c \bc_n$ so that $\bc_i=\b_i$ for $i\neq k\c k-1$ and $\bc_{k-1}=\b_k$, $\bc_k=\b_{k-1}$.  Note that $\tilde\bc_{k-1}$ is the projection of $\b_k$ on the orthogonal complement of the span of $\brace{\b_1,\dotsc,\b_{k-2}}$ and so $\tilde\bc_{k-1}=\tilde\b_k+\mu_{k,k-1}\tilde\b_{k-1}$.  Therefore
\[ \abs{\tilde\bc_{k-1}}^2 < \tfrac34\abs{\tilde\b_{k-1}}^2 . \]
In particular the ``new'' $\abs{\tilde\b_{k-1}}^2$ is less than $\frac34$ of the ``old'' $\abs{\tilde\b_{k-1}}^2$.  We now replace $k$ by $k-1$ and return to the start of the algorithm. \\
\textbf{Case 2:} If $k=1$ or
\[ \abs{\tilde\b_k+\mu_{k,k-1}\tilde\b_{k-1}}^2 \geq \tfrac34 \abs{\tilde\b_{k-1}}^2 \]
then \emph{we achieve} $\abs{\mu_{kj}}\leq\frac12$ for $1\leq j\leq k-1$; we replace $k$ by $k+1$ and we return to the start of the algorithm.

To achieve $\abs{\mu_{kj}}\leq\frac12$ for $1\leq j\leq k-1$ we do the following.  First note that $\mu_{k,k-1}\leq\frac12$.  Then let $l$ be the largest integer with $1\leq l<k-1$ for which $\abs{\mu_{kl}}>\frac12$.  Let $r$ be the integer closest to $\mu_{kl}$ and replace $\b_k$ by $\b_k-r\b_l$.  Note that $\mu_{kl}$ is then replaced by $\mu_{kl}-r$ and $\abs{\mu_{kl}-r}\leq\frac12$.

We now recalculate $\mu_{k,j}$ for $j<l$.  We then repeat the process until we have
\[ \abs{\mu_{kj}}\leq\tfrac12 \qquad\text{for $1\leq j\leq k-1$} . \]
We shall now show that the algorithm terminates after only finitely many steps.  We introduce the quantities for $1\leq i\leq n$.
\begin{align*}
d_i &= \det(\inn{\b_j,\b_l}) \text{ for $1\leq j\leq i$, $1\leq l\leq i$} \\
&= \det((\b_1,\dotsc,\b_i)\cdot(\b_1,\dotsc,\b_i)^\text{tr}) \\
&= \det((\tilde\b_1,\dotsc,\tilde\b_i)\cdot(\tilde\b_1,\dotsc,\tilde\b_i)^\text{tr})
\end{align*}
since the determinant does not change if we add a multiple of one row to another.  We put $D=\prod_{i=1}^n d_i$.  Note that $d_n=d(\Lambda)^2$.  Further,
\begin{align*}
d_i &= (\abs{\tilde\b_1}\dotsm\abs{\tilde\b_i})^2 = \det((\tilde\b_1,\dotsc,\tilde\b_i)\cdot(\tilde\b_1,\dotsc,\tilde\b_i)^\text{tr}) \\
&= \det((\b_1,\dotsc,\b_i)\cdot(\b_1,\dotsc,\b_i)^\text{tr}) \\
&= d(\Lambda_i)^2
\end{align*}
where $\Lambda_i$ is the lattice generated by $\b_1\c \dotsc\c \b_i$ in the $i$-dimensional subspace of $\R^n$ spanned by these vectors.  Note that $D$ changes only if one of the $\tilde\b_i$s changes and this only occurs in case 1.  Further in case 1 we interchange $\b_k$ and $\b_{k-1}$.  Since $d_i = (\abs{\tilde\b_1}\dotsm\abs{\tilde\b_i})^2$ we see that $d_i$ only changes when $i=k-1$ in which case it gets smaller by a factor of at least $3/4$.  Further $D$ is smaller by a factor of at least $3/4$.  To complete our argument we'll show that $D$ is bounded from below in terms of $\Lambda$.

Put $m(\Lambda) = \min\set{\x\cdot\x}{\x\in\Lambda\c \x\neq\0}$.  By Theorem 10,
\[ m(\Lambda_i) \leq 4 \paren{\omega_i^{-1} d(\Lambda_i)}^{2/i} \]
hence
\[ d_i \geq m(\Lambda_i)^i 4^{-i} \omega_i^2 . \]
Since $m(\Lambda_i)\geq m(\Lambda)$,
\[ d_i \geq m(\Lambda)^i 4^{-i} \omega_i^2, \text{ for $i=1\c \dotsc\c n$}. \]
Thus
\[ D = d_1\dotsm d_n \geq \paren*{\frac{m(\Lambda)}{4}}^{n(n+1)/2} (\omega_1\dotsm\omega_n)^2 \]
as required.

Therefore we can pass through case 1 only finitely many times.  In case 1, $k$ decreases by 1.  In case 2, $k$ increases by 1 and so after finitely many steps $k=n+1$ and our algorithm terminates.

In fact the algorithm is efficient.  Lenstra, Lenstra, and Lov\'asz proved that if $\Lambda$ is a sublattice of $\Lambda_0$ with basis $\b_1\c \dotsc\c \b_n$ and if $B$ is a real number with $B\geq2$ and
\[ \abs{\b_i}^2 \leq B \qquad\text{for $i=1\c \dotsc\c n$} \]
then the number of arithmetical operations needed for the \LLL-algorithm is $O(n^4\log B)$ and the integers on which these operations are performed have binary length $O(n\log B)$.  By an arithmetical operation I mean an addition, subtraction, multiplication, or division, and by the binary length of an integer $n$, I mean the length or number of digits in the base 2 expansion of $n$.  The algorithm runs in polynomial time in terms of $B$.